#!/usr/bin/env perl
#
# SniperlCat
#
##############################################################################
#  Copyright (C) 2010 Kenkeiras <kenkeiras@gmail.com>
#
#  This program is free software. It comes without any warranty, to
#  the extent permitted by applicable law. You can redistribute it
#  and/or modify it under the terms of the Do What The Fuck You Want
#  To Public License, Version 2, as published by Sam Hocevar. 
#
#  See http://sam.zoy.org/wtfpl/COPYING for more details.
##############################################################################

my $appname = "Sniperlcat";
$app_icon = "";

$network = "192.168.1.*";
$verbose = 0;
$cansino = 0;

my $go_back = 0;
my $arp_fill = 1;
my $file = "";
my $sltime = 60;

use Gtk2::Notify -init, "Sniperlcat";

# Se va al fondo
sub daemonize{
    $verbose = 0;
	umask 0;
	open STDIN, "</dev/null" || die $!;
	open STDOUT,">>/dev/null" || die $!;
	open STDERR, ">>/dev/null" || die $!;
	defined ($pid=fork) || die $!;
	exit if $pid;
	setsid || die $!;
}

sub show_help{
        print "$appname\n";
        print "sniperlcat [-h]|[-d | -v ] [-nf] [-c] [-n <red>] [-f <descriptor de red>] [-s <tiempo>]\n";
        print "-h  (--help): Muestra este mensaje\n";
        print "-d  (--daemonize): Se ejecuta de fondo\n";
        print "-nf (--no-fill): No llena la tabla de hosts (con nmap) antes de leerla\n";
        print "-c  (--cansino): Repite los avisos, aún los ya emitidos, en cada iteración\n";
        print "-v  (--verbose): Muestra más información por pantalla\n";
        print "-n  (--network): Especifica la red donde se ejecuta, por defecto 192.168.1.0/24\n";
        print "-f  (--file): Especifica el archivo de red inicial (se obtiene con arp -an)\n";   
        print "-s  (--sleep): Especifica el tiempo en segundos de \"descanso\" entre iteraciones (por defeto 60)\n";   
}

# Comprueba los parámetros

my $i = 0;
while ($i <= $#ARGV){
    if (($ARGV[$i] eq "-d") || ($ARGV[$i] eq "--daemonize")){
        $go_back = 1;
    }
    elsif (($ARGV[$i] eq "-h") || ($ARGV[$i] eq "--help")){
        show_help;
        exit 0;
    }
    elsif (($ARGV[$i] eq "-v") || ($ARGV[$i] eq "--verbose")){
        $verbose = 1;
    }
    elsif (($ARGV[$i] eq "-c") || ($ARGV[$i] eq "--cansino")){
        $cansino = 1;
    }
    elsif (($ARGV[$i] eq "-nf") || ($ARGV[$i] eq "--no-fill")){
        $arp_fill = 0;
    }
    elsif (($ARGV[$i] eq "-n") || ($ARGV[$i] eq "--network")){
        $i++;
        if ($i > $#ARGV){
            print "No se ha especificado la red\n";
            show_help;
            exit 1;
        }
        $network = $ARGV[$i];
    }
    elsif (($ARGV[$i] eq "-f") || ($ARGV[$i] eq "--file")){
        $i++;
        if ($i > $#ARGV){
            print "No se ha especificado el archivo de red\n";
            show_help;
            exit 1;
        }
        $file = $ARGV[$i];
    }
    elsif (($ARGV[$i] eq "-s") || ($ARGV[$i] eq "--sleep")){
        $i++;
        if ($i > $#ARGV){
            print "No se ha especificado el tiempo\n";
            show_help;
            exit 1;
        }
        $sltime = $ARGV[$i];
    }

    $i++;
}

daemonize if $go_back;

# LLena la tabla arp con nmap
sub fill_arp_table{
    `nmap $network -sP 2>/dev/null 1>/dev/null`;
}

# Carga la tabla arp de un archivo
sub load_arp_desc{
    my %tmplist = ();
    my $arp = $_[0];
    my @lines = split(/\n/,$arp);
    my $ip,$mac,$i = 0;
    my $max = @lines;
    while ($i < $max){
        # Extrae la IP
        @line = split(/ /,@lines[$i]);
        @ip = split(/\(/,$line[1]);
        @ip = split(/\)/,@ip[1]);
        $ip = @ip[0];

        # Y la MAC
        $mac = $line[3];

        # Y se introduce en la lista si es una MAC válida
        if (substr("$mac", 0, 1) ne "<"){
            $tmplist{"$ip"} = "$mac";
        }
        $i++;
    }
    return %tmplist;
}

# Carga la tabla arp
sub load_arp_list{
    my $arp = `arp -an`;
    return load_arp_desc($arp);
}

# Hace las comprobaciones
sub check_list{
    my $ip_list = $_[0];
    my $tmplist = $_[1];
    my $lastlist = $_[2];
    foreach my $ip (keys %$tmplist){
        my $mac = $tmplist->{$ip};

        # Si es un host nuevo
        if (!exists $ip_list->{$ip} ) {
            if ((!exists $lastlist->{$ip}) || ($cansino)){
                my $message = "Equipo desconocido en la red: $ip [$mac]";
                if ($mac ne "00:00:00:00:00"){ # Se suele utilizar para tapar
                                               # despues de arp spoofing.
                                               # No aporta nada
                    # Si la MAC está repetida, probablemente haya spoofing
                    foreach my $tmpip (keys %$ip_list){
                        if (($ip_list->{$tmpip} eq $mac) && ($tmpip ne $ip)){
                            $message .= ", posiblemente spoofeado desde $tmpip";
                        }
                    }
                }
                print "$message\n" if $verbose;
                my $notification = Gtk2::Notify->new("$appname", "$message","$app_icon");
                $notification->show();
            }
        }
        else{
            # Si cambio la MAC
            if ($ip_list->{$ip} ne $mac){
                if (($lastlist->{$ip} ne $mac)||($cansino)){
                    my $message = "La MAC de $ip ha cambiado de [".$lastlist->{$ip}."] a [".$mac."]";
                    if ($mac ne "00:00:00:00:00"){ # Se suele utilizar para tapar
                                                   # despues de arp spoofing.
                                                   # No aporta nada
                        # Si la MAC está repetida, probablemente haya spoofing
                        foreach my $tmpip (keys %$ip_list){
                            if (($ip_list->{$tmpip} eq $mac) && ($tmpip ne $ip)){
                                $message .= ", posiblemente spoofeado desde $tmpip";
                            }
                        }
                    }
                    print "$message\n" if $verbose;
                    my $notification = Gtk2::Notify->new("$appname", "$message","$app_icon");
                    $notification->show();
                }
            }
        }
    }
}

my %ip_list;
if ($file eq ""){
    if ($arp_fill){
        print STDERR "LLenando lista arp... " if $verbose;
        fill_arp_table;
        print STDERR "[OK]\n" if $verbose;
    }
    print STDERR "Leyendo tabla arp... " if $verbose;
    %ip_list = load_arp_list;
    print STDERR "[OK]\n" if $verbose;
}
else{
    local $/=undef;
    open MYFILE, "$file" or die "Couldn't open file: $!";
    binmode MYFILE;
    $arp = <MYFILE>;
    close MYFILE;
    %ip_list = load_arp_desc("$arp");
}

my $lastlist = \%ip_list;
while (1){
    if ($arp_fill){
        fill_arp_table;
    }
    my %tmplist = load_arp_list;
    check_list(\%ip_list,\%tmplist,$lastlist);
    $lastlist = \%tmplist;
    sleep $sltime;
}
